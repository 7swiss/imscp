#!/usr/bin/perl

=head1 NAME

 imscp-backup-all backup i-MSCP customer's data.

=head1 SYNOPSIS

 imscp-backup-all [options]...

=cut

# i-MSCP - internet Multi Server Control Panel
# Copyright (C) 2010-2017 by Laurent Declercq <l.declercq@nuxwin.com>
#
# This program is free software; you can redistribute it and/or
# modify it under the terms of the GNU General Public License
# as published by the Free Software Foundation; either version 2
# of the License, or (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.

use strict;
use warnings;
use File::Basename;
use FindBin;
use lib "$FindBin::Bin/../PerlLib", "$FindBin::Bin/../PerlVendor";
use iMSCP::Bootstrapper;
use iMSCP::Debug qw/ debug error getMessageByType newDebug setVerbose /;
use iMSCP::Dir;
use iMSCP::Execute qw/ execute /;
use iMSCP::Ext2Attributes qw/ isImmutable setImmutable clearImmutable /;
use iMSCP::Getopt;
use iMSCP::Mail;
use Servers::mta;
use POSIX qw/ strftime /;
use POSIX qw/ locale_h /;
use locale;

setlocale( LC_ALL, 'C.UTF-8' );
$ENV{'LANG'} = 'C.UTF-8';

my $command = {
    bzip2  => {
        extension => 'bz2',
        command   => 'bzip2'
    },
    pbzip2 => {
        extension => 'bz2',
        command   => 'pbzip2'
    },
    gzip   => {
        extension => 'gz',
        command   => 'gzip'
    },
    pigz   => {
        extension => 'gz',
        command   => 'pigz'
    },
    lzma   => {
        extension => 'lzma',
        command   => 'lzma'
    },
    xz     => {
        extension => 'xz',
        command   => 'xz'
    }
};

=head1 DESCRIPTION

 Backup customer data

=head1 PUBLIC METHODS

=over 4

=item backupHomedir( $homeDir, $bkpDir, $cmpAlgo, $cmpLevel, $bkpExt, $user, $group )

 Backup a customer home directory

 Param string $homeDir Home directory path
 Param string $bkpDir Backup directory path
 Param string $cmpAlgo Compression algorithm
 Param string $cmpLevel Compression level
 Param string $bkpExt Backup archive extension
 Param string $user Customer unix user
 Param string $group Customer unix group
 Return void

=cut

sub backupHomedir
{
    my ($homeDir, $bkpDir, $cmpAlgo, $cmpLevel, $bkpExt, $user, $group) = @_;

    my $bkpDate = strftime "%Y.%m.%d-%H-%M", localtime;
    my $bkpArchName = "web-backup-$bkpDate.tar$bkpExt";

    my @cmd = (
        "tar -c -C $homeDir --exclude=logs --exclude=phptmp --exclude=backups .",
        ($cmpAlgo eq 'no'
            ? "-f $bkpDir/$bkpArchName" : "| $command->{$cmpAlgo}->{'command'} -$cmpLevel > $bkpDir/$bkpArchName"
        )
    );

    my $rs = execute( "@cmd", \my $stdout, \my $stderr );
    debug( $stdout ) if $stdout;

    # tar exit with status 1 only if some files were changed while being read. We want ignore this.
    if ($rs > 1) {
        error( $stderr || 'Unknown error' ) if $stderr;
        return;
    }

    my $file = iMSCP::File->new( filename => "$bkpDir/$bkpArchName" );
    $rs ||= $file->owner( $user, $group );
    $rs ||= $file->mode( 0644 );
}

=item backupDatabases( $mainDomainId, $bkpDir, $cmpAlgo, $cmpLevel, $bkpExt, $user, $group )

 Backup customer databases

 Param string $mainDomainId Customer main domain ID
 Param string $bkpDir Backup directory path
 Param string $cmpAlgo Compression algorithm
 Param string $cmpLevel Compression level
 Param string $bkpExt Backup archive extension
 Param string $user Customer unix user
 Param string $group Customer unix group
 Return void

=cut

sub backupDatabases
{
    my ($mainDomainId, $bkpDir, $cmpAlgo, $cmpLevel, $user, $group) = @_;

    my $db = iMSCP::Database->factory( );
    my $data = $db->doQuery(
        'sqld_name', 'SELECT sqld_id, sqld_name FROM sql_database WHERE domain_id = ?', $mainDomainId
    );
    unless (ref $data eq 'HASH') {
        error( $data );
        return 1;
    }

    for (keys %{$data}) {
        next if $db->dumpdb( $_, "$bkpDir/$_.sql" );

        my $file = iMSCP::File->new( filename => "$bkpDir/$_.sql" );
        my $rs = $file->owner( $user, $group );
        $rs ||= $file->mode( 0644 );

        next if $rs || $cmpAlgo eq 'no';

        $rs = execute(
            [ $command->{$cmpAlgo}->{'command'}, "-$cmpLevel", '--force', "$bkpDir/$_.sql" ],
            \ my $stdout,
            \ my $stderr
        );
        debug( $stdout ) if $stdout;
        error( $stderr || 'Unknown error' ) if $rs;
    }
}

=item backupMaildirs( $domainId, $bkpDir, $cmpAlgo, $cmpLevel, $bkpExt, $user, $group )

 Backup customer' mail directories

 Param string $domainId Customer main domain ID
 Param string $bkpDir Backup directory path
 Param string $cmpAlgo Compression algorithm
 Param string $cmpLevel Compression level
 Param string $bkpExt Backup archive extension
 Param string $user Customer unix user
 Param string $group Customer unix group
 Return void

=cut

sub backupMaildirs
{
    my ($domainId, $bkpDir, $cmpAlgo, $cmpLevel, $bkpExt, $user, $group) = @_;

    my $qrs = iMSCP::Database->factory( )->doQuery(
        'domain_name',
        "
            SELECT domain_name
            FROM domain
            WHERE domain_id = ?
            AND domain_status <> 'todelete'

            UNION ALL

            SELECT CONCAT(subdomain_name, '.', domain_name)
            FROM subdomain
            INNER JOIN domain USING(domain_id)
            WHERE domain_id = ?
            AND subdomain_status <> 'todelete'

            UNION ALL

            SELECT alias_name
            FROM domain_aliasses
            WHERE domain_id = ?
            AND alias_status <> 'todelete'

            UNION ALL

            SELECT CONCAT(subdomain_alias_name, '.', alias_name)
            FROM subdomain_alias
            INNER JOIN domain_aliasses USING(alias_id)
            WHERE domain_id = ?
            AND subdomain_alias_status <> 'todelete'
        ",
        $domainId,
        $domainId,
        $domainId,
        $domainId
    );
    unless (ref $qrs eq 'HASH') {
        error( $qrs );
        next;
    }

    my $bkpDate = strftime "%Y.%m.%d-%H-%M", localtime( );
    my $bkpArchName = "mail-backup-$bkpDate.tar$bkpExt";
    my $virtualMailDir = Servers::mta->factory( )->{'config'}->{'MTA_VIRTUAL_MAIL_DIR'};

    for (keys %{$qrs}) {
        my $mailDirPath = "$virtualMailDir/$_";
        next unless -d $mailDirPath;

        my @cmd = (
            "tar -c -C $mailDirPath .",
            ($cmpAlgo eq 'no'
                ? "-f $bkpDir/$bkpArchName"
                : "| $command->{$cmpAlgo}->{'command'} -$cmpLevel > $bkpDir/$bkpArchName"
            )
        );

        my $rs = execute( "@cmd", \ my $stdout, \ my $stderr );
        debug( $stdout ) if $stdout;

        if ($rs > 1) {
            error( $stderr || 'Unknown error' );
        }

        my $file = iMSCP::File->new( filename => "$bkpDir/$bkpArchName" );
        $rs ||= $file->owner( $user, $group );
        $rs = $file->mode( 0644 );
    }
}

=item backupAll( )

 Backup customer data

=cut

sub run
{
    return 0 unless $main::imscpConfig{'BACKUP_DOMAINS'} eq 'yes';

    my $cmpAlgo = lc( $main::imscpConfig{'BACKUP_COMPRESS_ALGORITHM'} );
    $cmpAlgo = 'no' unless $cmpAlgo eq 'no' || exists $command->{$cmpAlgo};

    my ($cmpLevel) = $main::imscpConfig{'BACKUP_COMPRESS_LEVEL'} =~ /^([1-9])$/;
    $cmpLevel ||= 1;

    my $bkpExt = ($cmpAlgo ne 'no') ? '.'.$command->{$cmpAlgo}->{'extension'} : '';

    my $qrs = iMSCP::Database->factory( )->doQuery(
        'domain_id',
        "
            SELECT domain_id, domain_name, domain_admin_id, allowbackup, admin_sys_name, admin_sys_gname
            FROM domain
            INNER JOIN admin ON (admin_id = domain_admin_id)
            WHERE domain_status NOT IN ('disabled', 'todelete')
            AND allowbackup <> ''
        "
    );

    unless (ref $qrs eq 'HASH') {
        error( $qrs );
    } else {
        while(my ($domainId, $domainData) = each( %{$qrs} )) {
            next unless $domainData->{'allowbackup'} && $domainData->{'allowbackup'} =~ /\b(?:dmn|sql|mail)\b/;
            my $homeDir = "$main::imscpConfig{'USER_WEB_DIR'}/$domainData->{'domain_name'}";

            next unless -d $homeDir;

            my $bkpDir = "$homeDir/backups";
            my $user = $domainData->{'admin_sys_name'};
            my $group = $domainData->{'admin_sys_gname'};

            local $@;
            eval {
                unless (-d $bkpDir) {
                    my $isProtectedHomedir = 0;

                    if (isImmutable( $homeDir )) {
                        $isProtectedHomedir = 1;
                        clearImmutable( $homeDir );
                    }

                    iMSCP::Dir->new( dirname => $bkpDir )->make(
                        {
                            user  => $user,
                            group => $group,
                            mode  => 0750
                        }
                    );

                    setImmutable( $homeDir ) if $isProtectedHomedir;
                } else {
                    iMSCP::Dir->new( dirname => $bkpDir )->clear( undef, qr/.*/ );
                }
            };
            if ($@) {
                error( $@ );
                next;
            }

            if ($domainData->{'allowbackup'} =~ /\bdmn\b/) {
                backupHomedir( $homeDir, $bkpDir, $cmpAlgo, $cmpLevel, $bkpExt, $user, $group )
            }

            if ($domainData->{'allowbackup'} =~ /\bsql\b/) {
                backupDatabases( $domainId, $bkpDir, $cmpAlgo, $cmpLevel, $bkpExt, $user, $group );
            }

            if ($domainData->{'allowbackup'} =~ /\bmail\b/) {
                backupMaildirs( $domainId, $bkpDir, $cmpAlgo, $cmpLevel, $bkpExt, $user, $group );
            }
        }
    }

    my @errors = getMessageByType( 'error', { remove => 0 } );
    iMSCP::Mail->new( )->errmsg( "@errors" ) if @errors;
}

newDebug( 'imscp-backup-all.log' );

iMSCP::Getopt->parseNoDefault( sprintf( "Usage: perl %s [OPTION]...", basename( $0 ) ).qq {

Script that backup i-MSCP customer's data.

OPTIONS:
 -v,    --verbose       Enable verbose mode.},
    'debug|d'   => \&iMSCP::Getopt::debug,
    'verbose|v' => \&iMSCP::Getopt::verbose
);

setVerbose( iMSCP::Getopt->verbose );

my $bootstrapper = iMSCP::Bootstrapper->getInstance( );
exit unless $bootstrapper->lock( '/tmp/imscp-backup-all.lock', 'nowait' );

$bootstrapper->boot(
    {
        config_readonly => 1,
        nolock          => 1,
        norequirements  => 1
    }
);

run( );

END { $bootstrapper->unlock( '/tmp/imscp-backup-all.lock' ); }

=back

=head1 AUTHOR

 Laurent Declercq <l.declercq@nuxwin.com>

=cut
