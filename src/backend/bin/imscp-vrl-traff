#!/usr/bin/perl

=head1 NAME

 imscp-srv-traff - Collects customers traffic data (http, ftp, imap/pop3, smtp).

=head1 SYNOPSIS

 imscp-srv-traff [OPTION]...

=cut

# i-MSCP - internet Multi Server Control Panel
# Copyright (C) 2010-2018 by Laurent Declercq <l.declercq@nuxwin.com>
#
# This program is free software; you can redistribute it and/or
# modify it under the terms of the GNU General Public License
# as published by the Free Software Foundation; either version 2
# of the License, or (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.

use strict;
use warnings;
use File::Basename 'basename';
use iMSCP::Boolean;
use iMSCP::Bootstrapper;
use iMSCP::Config;
use iMSCP::Database;
use iMSCP::Debug qw/ debug error getMessageByType newDebug /;
use iMSCP::EventManager;
use iMSCP::Getopt;
use iMSCP::LockFile;
use iMSCP::Mail;
use iMSCP::Server::ftpd;
use iMSCP::Server::httpd;
use iMSCP::Server::mta;
use iMSCP::Server::po;
use POSIX 'locale_h';

setlocale( LC_MESSAGES, 'C.UTF-8' );

$ENV{'LANG'} = 'C.UTF-8';

$> == 0 or die( "You do not have permission to call this script.\n" );

exit unless iMSCP::LockFile->new( path => "$::imscpConfig{'LOCK_DIR'}/imscp-vrl-traff.lock", non_blocking => TRUE )->acquire();

iMSCP::Getopt->parse( sprintf( 'Usage: perl %s [OPTION]...', basename( $0 )) . qq{

Script that collects i-MSCP customers' traffic data (http, ftp, imap/pop3, smtp).

OPTIONS:
 -d,   --debug   Enable debug mode.
 -h,-? --help    Show this help.
 -v,   --verbose Enable verbose mode.
},
    'debug|d'   => \&iMSCP::Getopt::debug,
    'help|?|h'  => \&iMSCP::Getopt::showUsage,
    'verbose|v' => \&iMSCP::Getopt::verbose
);

newDebug( 'imscp-vrl-traff.log' );

iMSCP::Bootstrapper->getInstance()->boot( { config_readonly => TRUE } );

eval {
    my $rdbh = iMSCP::Database->factory()->getRawDb();
    local $rdbh->{'RaiseError'} = TRUE;

    # Get list of domains for which traffic must be collected
    my $sth = $rdbh->prepare(
        "
           SELECT domain_id AS upper_domain_id, domain_name
           FROM domain
           WHERE domain_status <> 'todelete'
           UNION ALL
           SELECT domain_id AS upper_domain_id, alias_name
           FROM domain_aliasses
           WHERE alias_status <> 'todelete'
           UNION ALL
           SELECT domain_id AS upper_domain_id, CONCAT(subdomain_name, '.', domain_name)
           FROM subdomain
           JOIN domain USING (domain_id)
           WHERE subdomain_status <> 'todelete'
           UNION ALL
           SELECT domain_id AS upper_domain_id, CONCAT(subdomain_alias_name, '.', alias_name)
           FROM subdomain_alias
           JOIN domain_aliasses USING (alias_id)
           WHERE subdomain_alias_status <> 'todelete'
       "
    );
    $sth->execute();

    my $domains = $sth->fetchall_hashref( 'domain_name' );
    return unless %{ $domains };

    my %domains = map { $_ => 0 } keys %{ $domains };
    my $timestamp = time();
    my $halfTimestamp = $timestamp-( $timestamp % 1800 );
    my %trafficDb;

    # Collects traffic data from each server implementing the getTraffic() method
    for my $server ( 'iMSCP::Server::httpd', 'iMSCP::Server::ftpd', 'iMSCP::Server::mta', 'iMSCP::Server::po' ) {
        next unless $server->can( 'getTraffic' );
        # Initialize intermediate traffic database
        tie %{ $trafficDb{$server} }, 'iMSCP::Config', fileName => "$::imscpConfig{'IMSCP_HOMEDIR'}/$server-vrl-traff.db", nodie => TRUE;
        %{ $trafficDb{$server} } = ( %domains, %{ $trafficDb{$server} } );
        # Collect traffic
        $server->factory()->getTraffic( $trafficDb{$server} );
    }

    # Updates traffic data in i-MSCP database

    while ( my ( $domainName, $domainData ) = each( %{ $domains } ) ) {
        # Don't process domain for which there are no traffic data
        next unless $trafficDb{'iMSCP::Server::httpd'}->{$domainName} || $trafficDb{'iMSCP::Server::ftpd'}->{$domainName}
            || $trafficDb{'iMSCP::Server::mta'}->{$domainName} || $trafficDb{'iMSCP::Server::po'}->{$domainName};
        $rdbh->do(
            '
                INSERT INTO domain_traffic (domain_id, dtraff_time, dtraff_web, dtraff_ftp, dtraff_mail, dtraff_pop
                ) VALUES (?, ?, ?, ?, ?, ?)
                ON DUPLICATE KEY UPDATE
                    dtraff_web = dtraff_web + ?, dtraff_ftp = dtraff_ftp + ?, dtraff_mail = dtraff_mail + ?, dtraff_pop = dtraff_pop + ?
            ',
            undef, $domainData->{'upper_domain_id'}, $halfTimestamp, $trafficDb{'iMSCP::Server::httpd'}->{$domainName},
            $trafficDb{'iMSCP::Server::ftpd'}->{$domainName}, $trafficDb{'iMSCP::Server::mta'}->{$domainName},
            $trafficDb{'iMSCP::Server::po'}->{$domainName}, $trafficDb{'iMSCP::Server::httpd'}->{$domainName},
            $trafficDb{'iMSCP::Server::ftpd'}->{$domainName}, $trafficDb{'iMSCP::Server::mta'}->{$domainName},
            $trafficDb{'iMSCP::Server::po'}->{$domainName}
        );
        $trafficDb{'iMSCP::Server::httpd'}->{$domainName} = 0;
        $trafficDb{'iMSCP::Server::ftpd'}->{$domainName} = 0;
        $trafficDb{'iMSCP::Server::mta'}->{$domainName} = 0;
        $trafficDb{'iMSCP::Server::po'}->{$domainName} = 0;
    }

    for my $server ( 'iMSCP::Server::httpd', 'iMSCP::Server::ftpd', 'iMSCP::Server::mta', 'iMSCP::Server::po' ) {
        untie( %{ $trafficDb{$server} } );
        iMSCP::File->new( filename => "$::imscpConfig{'IMSCP_HOMEDIR'}/$server-vrl-traff.db" )->remove();
    }
};
error( $@ ) if $@;

iMSCP::Mail->new()->errorMsg( scalar getMessageByType( 'error' ))->warnMsg( scalar getMessageByType( 'warn' ));

=head1 AUTHOR

 Laurent Declercq <l.declercq@nuxwin.com>

=cut

1;
__END__
